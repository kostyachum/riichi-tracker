name: Build and Deploy to Droplet

on:
  workflow_dispatch:

permissions:
  contents: read

env:
  APP_NAME: riichi-tracker

jobs:
  build-and-deploy:
    environment: deployment
    runs-on: ubuntu-latest
    env:
      REMOTE_DIR: ${{ vars.REMOTE_DIR }}
      APP_TAG: ${{ github.sha }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        run: |
          docker build \
            -t "$APP_NAME:${APP_TAG}" \
            -t "$APP_NAME:latest" \
            .

      - name: Save image as tarball
        run: |
          docker save "$APP_NAME:${APP_TAG}" | gzip > image.tar.gz

      - name: Load SSH key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add droplet to known_hosts
        env:
          SSH_HOST: ${{ secrets.DROPLET_HOST }}
          SSH_PORT: ${{ secrets.DROPLET_PORT != '' && secrets.DROPLET_PORT || '22' }}
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -p "$SSH_PORT" "$SSH_HOST" >> ~/.ssh/known_hosts

      - name: Create remote app directory
        env:
          SSH_HOST: ${{ secrets.DROPLET_HOST }}
          SSH_USER: ${{ secrets.DROPLET_USER }}
          SSH_PORT: ${{ secrets.DROPLET_PORT != '' && secrets.DROPLET_PORT || '22' }}
        run: |
          ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s -- "$REMOTE_DIR" <<'EOF'
          set -euo pipefail
          REMOTE_DIR="$1"
          mkdir -p "$REMOTE_DIR/db" "$REMOTE_DIR/config" "$REMOTE_DIR/staticfiles" "$REMOTE_DIR/media"
          EOF

      - name: Upload image to droplet
        env:
          SSH_HOST: ${{ secrets.DROPLET_HOST }}
          SSH_USER: ${{ secrets.DROPLET_USER }}
          SSH_PORT: ${{ secrets.DROPLET_PORT != '' && secrets.DROPLET_PORT || '22' }}
        run: |
          scp -P "$SSH_PORT" image.tar.gz "$SSH_USER@$SSH_HOST:$REMOTE_DIR/image.tar.gz"

      - name: Load image on droplet
        env:
          SSH_HOST: ${{ secrets.DROPLET_HOST }}
          SSH_USER: ${{ secrets.DROPLET_USER }}
          SSH_PORT: ${{ secrets.DROPLET_PORT != '' && secrets.DROPLET_PORT || '22' }}
        run: |
          ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s -- "$REMOTE_DIR" <<'EOF'
          set -euo pipefail
          REMOTE_DIR="$1"
          docker load -i "$REMOTE_DIR/image.tar.gz"
          rm -f "$REMOTE_DIR/image.tar.gz"
          EOF

      - name: Upload .env to droplet
        env:
          SSH_HOST: ${{ secrets.DROPLET_HOST }}
          SSH_USER: ${{ secrets.DROPLET_USER }}
          SSH_PORT: ${{ secrets.DROPLET_PORT != '' && secrets.DROPLET_PORT || '22' }}
          VARS_ENV: ${{ vars.ENV }}
        run: |
          set -euo pipefail
          if [ -z "${VARS_ENV}" ]; then
            echo "vars.ENV is empty or undefined" >&2
            exit 1
          fi
          tmpfile=$(mktemp)
          # Preserve newlines exactly
          printf '%s\n' "$VARS_ENV" > "$tmpfile"
          scp -P "$SSH_PORT" "$tmpfile" "$SSH_USER@$SSH_HOST:$REMOTE_DIR/.env"
          rm -f "$tmpfile"

      - name: Upload compose file to droplet
        env:
          SSH_HOST: ${{ secrets.DROPLET_HOST }}
          SSH_USER: ${{ secrets.DROPLET_USER }}
          SSH_PORT: ${{ secrets.DROPLET_PORT != '' && secrets.DROPLET_PORT || '22' }}
        run: |
          scp -P "$SSH_PORT" docker-compose.prod.yml "$SSH_USER@$SSH_HOST:$REMOTE_DIR/docker-compose.prod.yml"
      
      - name: Upload Nginx config to droplet
        env:
          SSH_HOST: ${{ secrets.DROPLET_HOST }}
          SSH_USER: ${{ secrets.DROPLET_USER }}
          SSH_PORT: ${{ secrets.DROPLET_PORT != '' && secrets.DROPLET_PORT || '22' }}
        run: |
          scp -P "$SSH_PORT" config/nginx.conf "$SSH_USER@$SSH_HOST:$REMOTE_DIR/config/"
      
      - name: Ensure network and deploy (Compose)
        env:
          SSH_HOST: ${{ secrets.DROPLET_HOST }}
          SSH_USER: ${{ secrets.DROPLET_USER }}
          SSH_PORT: ${{ secrets.DROPLET_PORT != '' && secrets.DROPLET_PORT || '22' }}
        run: |
          ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s -- "$REMOTE_DIR" "$APP_NAME:$APP_TAG" <<'EOF'
          set -euo pipefail
          REMOTE_DIR="$1"
          APP_IMAGE_ARG="$2"
          cd "$REMOTE_DIR"
          docker network create gateway >/dev/null 2>&1 || true
          docker compose -f docker-compose.prod.yml down
          APP_IMAGE="$APP_IMAGE_ARG" docker compose -f docker-compose.prod.yml --project-name riichi-tracker up -d
          EOF

      - name: Retag latest and cleanup old images
        env:
          SSH_HOST: ${{ secrets.DROPLET_HOST }}
          SSH_USER: ${{ secrets.DROPLET_USER }}
          SSH_PORT: ${{ secrets.DROPLET_PORT != '' && secrets.DROPLET_PORT || '22' }}
        run: |
          ssh -p "$SSH_PORT" "$SSH_USER@$SSH_HOST" bash -s -- "$REMOTE_DIR" "$APP_NAME" "$APP_TAG" <<'EOF'
          set -euo pipefail
          : "${1:?REMOTE_DIR required}"; : "${2:?APP_NAME required}"; : "${3:?APP_TAG required}"
          REMOTE_DIR="$1"; APP_NAME="$2"; APP_TAG="$3"
          CURRENT_REF="$APP_NAME:$APP_TAG"

          # Point :latest to the deployed image
          if docker image inspect "$CURRENT_REF" >/dev/null 2>&1; then
            docker tag "$CURRENT_REF" "$APP_NAME:latest" || true
          fi

          # Remove all other tags for this repo, keep current and latest
          mapfile -t TAGS < <(docker images "$APP_NAME" --format '{{.Repository}}:{{.Tag}}' | grep -E "^${APP_NAME}:" || true)
          for tag in "${TAGS[@]}"; do
            if [ "$tag" = "$CURRENT_REF" ] || [ "$tag" = "$APP_NAME:latest" ]; then
              continue
            fi
            docker rmi "$tag" || true
          done

          # Clean up dangling layers
          docker image prune -f || true
          EOF
